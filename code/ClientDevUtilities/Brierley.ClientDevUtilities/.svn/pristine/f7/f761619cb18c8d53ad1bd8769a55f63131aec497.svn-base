//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by _________?
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;
using System.Reflection;

using Brierley.FrameWork.Common;
using Brierley.FrameWork.Common.Config;
using Brierley.FrameWork.Data;
using Brierley.FrameWork.Data.DomainModel;

using PetaPoco;

namespace ${clazz.Namespace}.Mappers
{
	public class ${clazz.Name}Mapper : IMapper
	{
		private static LWKeystore _keystore = null;

		/// <summary>
		/// PetaPoco Mapper for $clazz.Name. This class is autogenerated
		/// </summary>
		private PetaPoco.StandardMapper standardMapper = new PetaPoco.StandardMapper();

		static ${clazz.Name}Mapper()
		{
			LWConfiguration config = LWConfigurationUtil.GetCurrentConfiguration();
			if (config == null)
			{
				LWConfigurationContext ctx = LWConfigurationUtil.GetCurrentEnvironmentContext();
				config = new LWConfiguration(ctx.Organization, ctx.Environment);
			}
			_keystore = config.LWKeystore;
		}

		public Func<object, object> GetFromDbConverter(PropertyInfo pi, Type sourceType)
		{
			if (sourceType == typeof(string) && pi.PropertyType == typeof(string))
				return src =>
				{
					if (!string.IsNullOrWhiteSpace((string)src))
					{
						switch(pi.Name)
						{
#foreach($attribute in $clazz.Attributes)				
	#set ($e = $clazz.GetEncryptionType($attribute))
	#if($e != "none")
							case "$attribute.Name":
		#if($e == "encoded")
								return CryptoUtil.DecodeUTF8((string)src);
		#end
		#if($e == "weak")
								return CryptoUtil.Decryptv2(_keystore, (string)src);
		#end
		#if($e == "strong")
								return CryptoUtil.DecryptAsymmetricUTF8(_keystore, (string)src);
		#end
	#end
#end
							default:
								return (string)src;
						}
					}
					return (string)src;
				};
			return null;
		}

		public TableInfo GetTableInfo(Type pocoType)
		{
			return standardMapper.GetTableInfo(pocoType);
		}

		public ColumnInfo GetColumnInfo(PropertyInfo pocoProperty)
		{
			return standardMapper.GetColumnInfo(pocoProperty);
		}

		public Func<object, object> GetToDbConverter(PropertyInfo SourceProperty)
		{
			return dst =>
			{
				if (dst is string && SourceProperty.PropertyType == typeof(string) && !string.IsNullOrWhiteSpace((string)dst))
				{
					switch(SourceProperty.Name)
					{
#foreach($attribute in $clazz.Attributes)
	#set ($e = $clazz.GetEncryptionType($attribute))
	//encryption type for $attribute is $e
	#if($e != "none")
						case "$attribute.Name":
		#if($e == "encoded")
							dst = CryptoUtil.EncodeUTF8((string)dst);
		#end
		#if($e == "weak")
							dst = CryptoUtil.Encryptv2(_keystore, (string)dst);
		#end
		#if($e == "strong")
							dst = CryptoUtil.EncryptAsymmetricUTF8(_keystore, (string)dst);
		#end
						break;
	#end
#end
					}
				}
				return dst;
			};
		}
	}
}
